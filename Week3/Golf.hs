skips :: [a] -> [[a]]
skips x = map (s x) [1..(length x)]

-- | every nth item from x
s :: [a] -> Int -> [a]
s x n = map snd $ filter (m n . fst) $ zip [1..] x

-- | is i divisibie by d?
m :: Int -> Int -> Bool
m i d = d `mod` i == 0

-- Exercise 2 Local maxima

-- localMaxima returns a list of local maxima from a list of integers
-- p is an alias for localMaxima (because of code Golf)
-- if there are three or more elements, we check if the middle element is a 
-- local maximum. If so, we put it in a list with the rest of the localMaxima
-- (found by applying localMaxima to the remainder of the list). Otherwise, we
-- just find the localMaxima in the rest of the list.
-- If there are fewer than three elements left, there can no longer be any
-- localMaxima, so we return [] in that case
-- CodeGolf -- if y is a maximum, then z isn't -- no need to check, we can skip
-- ahead by just doing p (z:r)
-- CodeGolf -- True has fewer letters than otherwise
localMaxima :: [Integer] -> [Integer]
localMaxima = p
p (x:y:z:r)
   | y > x && y > z  = y : p (z:r)
   | True            = p (y:z:r)
p _ = []


-- Exercise 3 
-- Histogram 
histogram :: [Integer] -> String
histogram x =
    let y = h x
        in l (maximum y) y

-- generates string representation of histogram data generated by h
l :: Integer -> [Integer] -> String
l 0 _ = "==========\n0123456789\n"
l t x = map (c t) x ++ "\n" ++ l (t -1) x

-- takes threshold t and number n and returns character representation
c :: Integer -> Integer -> Char
c t n
   | n < t = ' '
   | True  = '*'

-- generates a line of data given inputs and which level we are on

-- function to generate histogram. outputs number of occurrences of each
-- integer 0-9
h :: [Integer] -> [Integer]
h x = map (o x) [0..9]

-- function that gets number of occurrences of the number n in a list
o :: [Integer] -> Integer -> Integer
o x n = toInteger $ length $ filter (== n) x

